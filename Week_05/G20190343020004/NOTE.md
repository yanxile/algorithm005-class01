#### 学习笔记：动态规划
##### 动态规划的实现及关键点
1. 动态规划和递归或分治没有根本上的区别（关键看有无最优子结构）
2. 动态规划和递归、分治的共性：找到重复子问题
3. 动态规划和递归、分治的差异性：
    * 最优子结构
    * 中途可以淘汰次优解 
##### DP例题解析：Fibonacci数列、路径计数
###### Fibonacci数列
1. Fibonacci数列优化：
    * 递归加缓存的方法，叫做记忆化搜索
    * 加缓存，如加一个数组，用于存储每个Fibonacci的数值，递归到此，判断存在该值，则不再计算
    ```
      int fib (int n, int[] memo) {
        if (n < 1) {
            return n;
        }
        if(memo[n] == 0) {
            memo[n] = fib(n - 1) + fib(n - 2);
        }
        return memo[n];
    }
    ```
2. Fibonacci数列求解方式
    * 递归的方式是自顶向下
    * 循环递推的方式是自底向上
    * 这两种方式并无优劣，但如果要培养功力，建议**自底向上递推**，不断训练自己的递推能力
    * 熟练后，都培养成自底向上的递推，这是所谓的动态规划的终极形态
###### 路径计数
1. 复杂的DP特点：
    * 维度变化了，状态有二维空间或者三维空间
    * 中间会有取舍最优子结构
2. 状态转移方程(DP方程)
    ```
        opt[i, j] = opt[i+1, j] + opt[i, j+1]

        完整逻辑：
        if a[i, j] = '空地':
            opt[i, j] = opt[i+1, j] + opt[i, j+1]
        else:
            opt[i, j] = 0
    ```
###### 动态规划关键点
1. 最优子结构 opt[n] = best_of(opt[n-1], opt[n-2], ...)
2. 存储中间状态：opt[i]
3. 递推公式（状态转移方程或者DP方程）
    * Fib: opt[i] = opt[n-1] + opt[n-2]
    * 二维路径：opt[i, j] = opt[i+1, j] + opt[i, j+1](且判断a[i, j]是否空地)
###### 解决动态规划问题三步走思路
1. 动态规划和分治、递归没有太多本质区别，依然是找最近重复性
    * 相对于分治、递归，只是多了个筛选过程
    * 最优子结构 opt[n] = best_of(opt[n-1], opt[n-2], ...)
        * 即推导出的第n个的值，是前面几个值最佳值
         * 这种最佳值，有时候就是前面值的累加，或最大值、最小值
2. 必须定义中间状态，并存储中间状态
    * 分治直接把中间状态放置递归里了，但动态归并必须存储起来，一般开个数组存储
3. 递归公式或叫DP方程
    * 不同问题的DP方程是不一样的
##### DP例题解析：最长公共子序列
1. 关键是要能够转为二维来递推，只在一维上是思考不出递推公式的
##### 动态规划小结
1. 打破自己的思维惯性，形成机器思维
    * 机器思维就是找重复性，机器只会ifelse，for loop
    * 像机器一样，思考如何将问题拆分为可以重复执行的步骤
2. 理解复杂逻辑的关键
3. 职业进阶的要点要领
    * 不要人肉递归，也就是不要亲力亲为，而是要放权授权信任下属让下属去做
    * 同时给予反馈，允许下属犯错
    * 只做分治那一段，只合并下属的成功，在把合并结果反馈给上一层