package com.exercise.week_three;/** * @ClassName: * @Description: * @Author: * @Date: *//** *@ClassName LeetCode_50_0340POW(X,N) *@Description *@Autor *@Date 2019/12/1521:27 *@Version 1.0 *@Example **/public class LeetCode_74_0340搜索二维矩阵 {    public static void main(String[] args) {        int[][] matrix = {{1}};        System.out.println(searchMatrix(matrix,1));    }    // 使用二分查找,看到题目的第一个思路。根据每个数组的最大值，找到目标数字所在数组，然后进行二分查找（也可以把整个二维数组进行二分）    public static boolean searchMatrix(int[][] matrix, int target) {        if (matrix == null || matrix.length ==  0 || matrix[0] == null || matrix[0].length  ==  0) return  false;        for (int i = 0; i < matrix.length; i++) {            if (target <= matrix[i][matrix[i].length-1]){                // 二分查找                int left = 0;                int mid = 0;                int right = matrix[i].length-1;                while (right >= left){                    mid = (right + left)/2; // 中位索引                    if (matrix[i][mid] ==  target){  // 等于直接分返回                        return true;                    }else if (matrix[i][mid] < target){ // 如果目标值>中位数，说明目标值在右侧区间，左边界缩为中位数                        left = mid + 1;                    }else {                        right = mid - 1;                    }                }                return false;            }        }        return false;    }    // 看到leetcode上的解法 ，进行优化。直接进行二分查找    public static boolean searchMatrix1(int[][] matrix, int target){        if (matrix == null || matrix.length ==  0 || matrix[0] == null || matrix[0].length  ==  0) {            return  false;        }        int row = matrix.length; // 数组外围长度        int col = matrix[0].length; // 每个数组长度        int start = 0;        int end = row * col - 1;  // 总数量        while (start <= end) {            int mid = start + (end - start) / 2; // 中位数            // mide/col代表，当前在哪个数组。mid%col表示在数组中哪个位置            if (matrix[mid / col][mid % col] == target) {                return true;            }            if (matrix[mid / col][mid % col] > target) {                end = mid - 1;            } else {                start = mid + 1;            }        }        return false;    }}