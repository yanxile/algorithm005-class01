package com.exercise.week_two.home;/** * @ClassName: * @Description: * @Author: * @Date: */import java.util.*;/** *@ClassName LeetCode_01_0340两数之和 *@Description *@Autor *@Date 2019/12/1521:27 *@Version 1.0 *@Example **/public class LeetCode_49_0340字母异位词分组 {    public static void main(String[] args) {        List<List<String>> list = groupAnagrams(new String[]{"eat", "tea", "tan", "ate", "nat", "bat"});        System.out.println(list.size());        String str = "aexzbcgef";        char[] charArray = str.toCharArray();        System.out.println(String.valueOf(str));    }    // 利用常规解法 ，将每个字符串排序后放到map里。    public static List<List<String>> groupAnagrams(String[] strs) {        // 边界条件        if (strs == null || strs.length < 0) {            return new ArrayList<>();        }        Map<String,LinkedList<String>> map = new HashMap<>();        for (String str:strs) {            char[] charArray = str.toCharArray();            Arrays.sort(charArray);            String strKey = String.valueOf(charArray);            // 这里key值char数组toString会变成地址值            LinkedList<String> strList = map.getOrDefault(strKey,new LinkedList<>());            strList.add(str);            map.put(strKey,strList);        }        return new LinkedList<>(map.values());    }    // leetCode国际站学到的，长见识了。    public static List<List<String>> groupAnagrams1(String[] strs) {        // 边界条件        if (strs == null || strs.length < 0) {            return new LinkedList<>();        }        Map<String,LinkedList<String>> map = new HashMap<>();        for (String str:strs) {            //利用int数组，as2码，生成每个key的唯一标识。。。注意key需要+上字符串长度。否则被极端案例击破。            int[] azArr = new int[26];            for (int i = 0; i < str.length(); i++) {                azArr[str.charAt(i)-'a']++;            }            String strKey = Arrays.toString(azArr)+str.length();            LinkedList<String> strList = map.getOrDefault(strKey,new LinkedList<>());            strList.add(str);            map.put(strKey,strList);        }        return new LinkedList<>(map.values());    }}