# 学习笔记

## HashMap 总结

### 1. 基本特点

HashMap 是 java 中用于映射(键值对)处理的数据类型。基于哈希表的 Map 接口的实现。最多只允许一条记录的键为 null，允许多条记录的值为 null。HashMap 不保证映射的顺序。特别是，它不能保证顺序会随着时间的推移保持恒定。

HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度 O(1)。

### 2. 存储结构

从结构实现来讲，HashMap 是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。

哈希表为了解决冲突，一般有两种方式来解决，开放寻址法和链表法。

开放寻址法：如果出现了散列冲突，就重新探测一个空闲位置，将其插入。

链表法：就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被 Hash 后，得到数组下标，把数据放在对应下标元素的链表上。

即使负载因子和 Hash 算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。

于是，在 JDK1.8 版本中，HashMap 做了进一步的优化，引入了红黑树。当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能。

### 3. hashMap 的 hash 算法

不管是添加、删除还是查找，第一步首先是要确定当前元素在 HashMap 中的位置。

HashMap 中的 hash 采用的是**取 key 的 hashCode 值，然后进行高位运算，再进行取模运算。**

```java
static final int hash(Object key) {
      int h;
      return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
  }
```

“与(&)”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。

HashMap 采用 key.hashCode() 与 hash 值的高 16 位进行异或运算。

利用高半区和低半区做异或，就是为了**混合原始哈希码的高位和低位，以此来加大低位的随机性**。混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来，减少 hash 碰撞的几率。

### HashMap 的扩容机制

扩容(resize)就是重新计算容量。

当我们不停的向 HashMap 中添加元素，当达到临界值，HashMap 无法添加新元素时，就需要进行扩容，以便能装入更多的元素。

在经过 resize 扩容后，数组的长度会扩大为原来的 2 倍，所以，**元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置**。

全文在此： [HashMap 解析](./HashMap.md)

## 树的面试题解法一般都是递归，为什么？

覃超老师在第七课讲了，一是节点的定义，另一个是重复性。

我说一下我个人的理解，通过这几天的做题，发现树的题目基本都可以用递归实现。

因为树是从上往下然后分为不同的结点，然后有不同的层级深度，每个层级的模式差不太多，因此肯定是有重复性的。

而递归就非常适合解决这类问题。

## 这周总结

这周总体来讲，比第一周好一些。早早的看了题目和作业，因此没有太狼狈。

时间的分配我觉得也比较合理，前两天是看的第 5 课哈希表，做题 + 作业，顺便还把 HashMap 的作业总结整理成了博客。

周三周四在学第 6 课二叉树，没学之前，二叉树对我来讲是挺高端的，但这几天学下来，做了几个题，当然不能说我掌握了，只是我不再特别怕他，虽然题目还是要看题解才能想出，或者写出来，但相比于之前看着它就怕，看着就觉得自己学不会来讲，也算是进步了。

第 7 课，递归是准备周五、周六学，然后周末回顾。周五看了递归的课程，做了一个实战题。

但是很不巧，这周末我感冒了，到现在也一直在头疼。因此递归的题目没有怎么做一些。

### 疑惑

这两周的学习，我确实有一些进步。

但是觉得五毒刷题法实践起来有点难。

比如周末时，我会拿一整个下午时间去学习，可能实战题会做 6、7 个，然后第三遍是 24 小时后再刷，因为隔天可能没有太多的时间，加上还有要学的，就导致无法刷完之前做的，因此题目越积越多，第三遍的完成率不高，很是苦恼。