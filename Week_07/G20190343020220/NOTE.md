学习笔记


## 学习总结

### 二进制运算

& 1&1=1 1&0 or 0&1 or 0&0 = 0;
| 1|1 or 0|1 or 1|0 =0 0|0=0;
^ 1^1 = 0; 1^0 or 0^1 = 1; 0^0 = 0;
n>>1  向右移1位  n<<1 向左移1位 <<< >>> 无符号左右移

### 基于比较的排序

* 冒泡排序. 比较 i和j, i<j  交换位置.    n^2   稳定的
* 选择算法. 每次选出最小的元素放在i的位置上, n^2  不稳定
* 插入排序. 将元素. 插入有序的数组中. n^2  稳定的 
* 希尔排序. 优化版本的插入排序. 在h距离的子数组是有序的. 利用的局部有序性. 不稳定 平均nlogn
* 归并排序. 将两个有序的子数组合并成一个数组. 稳定的   nlogn  n 分治
* 快速排序.  选择一个元素h. 将数组分为两部分. 前部分 <h 后部分>h.  不稳定 nlogn 分治
* 堆排序.  基于堆的特性. 应用一个大顶堆.  不稳定 nlogn 

### 非比较的排序

* 桶排序   桶平均划分为1-10 11-20 21-30. 然后各个桶使用归并排序. 最后自然有序
* 计数排序  只能应用于数字. 使用数组长度个数的桶. 下标代表元素大小. 每当遇见下标=元素的. v=1. 直到循环结束. 打印桶就可以了
* 基数排序 


### 位运算：
按位与：&
按位或：|
按位取反：~
按位异或(相同为零不同为一)：^
左移：<<
右移：>>

### XOR
x ^ 0 =x

x ^ 1s = ~x // 注意 1s = ~0
x ^ (~x) = 1s
x ^ x= 0
c = a ^ b => a ^ c = b, b ^ c = a a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c
// 交换两个数 // associative
### 指定位置的位运算：
将 x 最右边的 n 位清零:x & (~0 << n)
获取 x 的第 n 位值(0 或者 1): (x >> n) & 1
获取 x 的第 n 位的幂值:x & (1 << (n -1))
仅将第 n 位置为 1:x | (1 << n)
仅将第 n 位置为 0:x & (~ (1 << n))
将 x 最高位至第 n 位(含)清零:x & ((1 << n) - 1)
将第 n 位至第 0 位(含)清零:x & (~ ((1 << (n + 1)) - 1))
### 判断奇偶:
x % 2 == 1 —> (x & 1) == 1
x % 2 == 0 —> (x & 1) == 0
x >> 1 —> x / 2
即: x = x / 2; —> x = x >> 1;
mid = (left + right) / 2; —> mid = (left + right) >> 1;
X = X & (X-1) 清零最低位的 1
X & -X => 得到最低位的 1
X & ~X => 0


## leetcode刷题记录

### https://leetcode-cn.com/problems/number-of-1-bits/ 191. 位1的个数

n的位数是32位. 使用for循环 从0到32迭代. 每次迭代将1从0位向高位移动. 然后和n取& 看是否等于0  不等于0 count++

最后输出count

1 & 1 = 1; 1&0=0; 0&1=0; 0&0 = 0;

### https://leetcode-cn.com/problems/power-of-two/ 231. 2的幂

判断n是否为2的次幂.  首先n必须大于0. 并且 n 和 n-1 去&运算 如果==0 说明就是2的次幂;

例如 2^2 = 4 = 0100   n-1 = 3 = 0011 ; 0100 & 0011 = 0000;


### https://leetcode-cn.com/problems/reverse-bits/ 190. 颠倒二进制位

2进制数 1101   int是32位. 这里只会写出低位4位. 高位全是零. 我们希望得到一个1101后面跟着28个0的二进制数
0000000000000000000000000001101 -> 1101000000000000000000000000000

int result = 0;

i = 0 

0000000000000000000000000001101 >> 0 = 0000000000000000000000000001101;

0000000000000000000000000001101 & 1 = 1; temp = 1

temp = temp << (31 -i); temp = 1000000000000000000000000000000;

result = result | temp;  保留高位1;1000000000000000000000000000000 | 0000000000000000000000000000000 = 1000000000000000000000000000000;


i = 1 

0000000000000000000000000001101 >> 1 =  0000000000000000000000000000110;

0000000000000000000000000000110 & 1 = 0; temp =0;

temp = temp << (31 -i); temp = 0000000000000000000000000000000

result = result | temp; 1000000000000000000000000000000 | 0000000000000000000000000000000 = 1000000000000000000000000000000;

n =2; 依次力推


### https://leetcode-cn.com/problems/counting-bits/description/ 338. 比特位计数

动态规划+1个数统计


### https://leetcode-cn.com/problems/lru-cache/ 146. LRU缓存机制

hash表的作用是 o(1)的时间负责度, 可以知道cache中是否存在. 
双向链表head和tail. 作为cache. 当添加node进入cache时. 验证cache中是否存在. 存在.删除原有的. 将node添加到head.  没见过时比较cache大小是否超过limit. 超过tail删除一个. 否在直接添加到head, 并添加到hash.