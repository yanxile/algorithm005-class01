学习笔记

# 位运算
## 位运算符
* 左移     <<     例如: 0011 => 0110
* 右移     >>     例如: 0110 => 0011
* 按位或    |      
* 按位与    &
* 按位取反  ~
* 按位异或(相同为零不同为一)   ^

## 实战位运算要点
* 判断奇偶  最后一位  是0  偶数   是1  奇数
* x>>1  ->   x/2
* X=X&(X-1) 清零最低位的 1
* X&-X => 得到最低位的 1
* X&~X => 0 把最低位的二进制1给去掉了

# 布隆过滤器 BloomFilter

## BloomFilter VS Hash Table
一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。
总结:如果查询不存在,肯定是不存在,如果查到了,则可能存在

优点是空间效率和查询时间都远远超过一般的算法,
缺点是有一定的误识别率和删除困难。

# LRU Cache
* 两个元素: 大小、替换策略
* Hash Table + Double LinkedList
* O(1)查询
* O(1)修改、更新

## 替换策略
* LFU - least frequently used
* LRU - least recently used 最近最少被使用的元素被淘汰出去

# 排序算法
## 比较类排序
* 定义:通过比较来决定元素间的相对次序,由于其时间复杂度不能突破O(nlogn),因此也称为非线性时间比较排序
* 例如:归并排序、快速排序、堆排序、冒泡排序
## 非比较类排序
* 定义:不通过比较来决定元素间的相对次序,他可以突破基于比较排序的时间下届,以线性时间运行,因此也被称为线性时间非比较类排序。
* 例如:计数排序、桶排序、基数排序

## 初级排序 - O(n^2)
* 选择排序(Selection Sort)
    每次找最小值,然后放到待排序数组的起始位置
~~~
function selectionSort($arr)
{
    $len = count($arr);
    for ($i = 0; $i < $len - 1; $i++) { //循环$len-1，原因：最后一个数就是排序的最后一个，所以就没有必要循环了
        $minIndex = $i;   //标记第$i为最小，也就是默认第一个数为最小
        for ($j = $i + 1; $j < $len; $j++) {  //循环除了第一个数之外的数
            if ($arr[$j] < $arr[$minIndex]) {
                $minIndex = $j; //如果有比标记的数小的数，则标记这个数为新的最小数，以此类推
            }
        }
        //每轮循环结束后，把最小数放到循环数的开始位置
        $temp = $arr[$i];
        $arr[$i] = $arr[$minIndex];
        $arr[$minIndex] = $temp;

    }

    return $arr;
}
~~~
* 插入排序(Insertion Sort)
    从前到后逐步构建有序序列;对于未排序数据,在已排序序列中从后向前扫描,找到相应位置并插入
~~~
function insertionSort($arr) {
    $len=count($arr);
    for ($i=1; $i < $len; $i++) {
        //获得当前需要比较的元素值。
        $tmp = $arr[$i];
        //内层循环控制 比较 并 插入
        for ($j = $i - 1; $j >= 0; $j--) {
            //$arr[$i];//需要插入的元素; $arr[$j];//需要比较的元素
            if ($tmp < $arr[$j]) {
                //发现插入的元素要小，交换位置
                //将后边的元素与前面的元素互换
                $arr[$j + 1] = $arr[$j];
                //将前面的数设置为 当前需要交换的数
                $arr[$j] = $tmp;
            } else {
                //如果碰到不需要移动的元素
                //由于是已经排序好是数组，则前面的就不需要再次比较了。
                break;
            }
        }
    }
    //将这个元素 插入到已经排序好的序列内。
    //返回
    return $arr;
}
~~~
* 冒泡排序(Bubble Sort)
    嵌套循环,每次查看相邻的元素如果逆序,则交换。
~~~
function bubbleSort($arr) {
    for ($i=0;$i<count($arr);$i++) {
        $tmp = '';
        for ($j=$i+1;$j<count($arr)-1;$j++) {
            if ($arr[$i] > $arr[$j]) {
                $tmp = $arr[$i];
                $arr[$i] = $arr[$j];
                $arr[$j] = $tmp;
            }
        }
    }
    return $arr;
}
~~~
## 高级排序 - O(N*logN)
* 快速排序 (Quick Sort)
    数组取标杆priot,将小元素放pivot左边,大元素放右侧,然后依次对右边和右边的子数组继续排序; 以达到整个序列有序。
 
* 归并排序 (Merge Sort) - 分治
    1、把长度为n的输入序列分成两个长度为n/2 的子序列;
    2、对这两个子序列分别采用归并排序;
    3、将两个排序好的子序列合并成一个最终的排序序列;
~~~
小结:
归并和快排具有相似性,但步骤顺序相反
归并:先排序左右数组,然后合并两个有序子序列
快排:先调配出左右子数组,然后对左右子数组进行排序
~~~

* 堆排序 (Heap Sort) - 堆插入O(logN) ,取最大最小O(1)
    1、数组元素依次建立小顶堆
    2、依次取堆顶元素,并删除



