第一周的算法学习笔记

本周学习经验总结：
1. 做题时首先思考几分钟，认真读题，若思考后有头绪则尝试coding,若无头绪，直接看优秀的题解。
2. 分析透彻题目的思想后，尝试多种方式实现，当周T+1循环做题加强记忆熟练程度。

### 超哥语录
1. 多次读题明确问题及其边界条件，考虑多种解法及其时间空间复杂度，之后再coding && unit testing
2. 放弃死磕，兼顾效率。题目不是只做一次就可以了。吸收学习官方题解还有国际站的优秀代码，先将解题的思考和套路学习到，再独立多次刷题。一周、一个月后再做，面试前也要做一次全面的复习。
3. 因为我们的语言里面只有if、else、for loop、recursion的特性，也只能做些重复性的工作。所以问题到最后都是找base case（基本情况）和 recursive case

### 第一周算法解题思路&数据结构总结
1. 跳表遍历的时间复杂度从O(n)降为O(logn)，空间复杂度从O(1)变为O(n)
2. 移动零：单指针+循环
3. 盛水最多的容器：左右指针，夹逼准则
4. 爬楼梯：最近重复子问题推理
5. 3数之和：利用左右下标双指针，先排序可以避免在思考去重的问题上纠结
6. 链表：对next和pre节点的操作
7. 两个队列可以实现栈，两个栈可以实现队列
8. 栈适合用于解决最近相关性的问题（洋葱模型）
9. 滑动窗口：利用双端队列来解决
10. 柱状图中的最大矩形：利用有序的辅助栈
11. 接雨水：双指针。对数组中每个元素，找出下雨后能达到的最高位置，等于量表最大高度的最小值，减去当前高度的值

### hashTable学习
1. 什么是哈希表？
    * 哈希表（HashTable）又叫做散列表，是根据关键码值（即键值对）而直接访问的数据结构。也就是说，它通过把关键码映射到表中一个位置来访问记录，以加快查找速度。看到这里你可能比较疑惑，它是怎么加快查找速度的？下一节就有说明！这个映射函数就叫做散列（哈希）函数，存放记录的数组叫做散列表。

2. 为什么哈希表的速度快？
    * 在数据结构中，我们对两种数据结构应该会非常熟悉：数组与链表。数组的特点就是查找容易，插入删除困难；而链表的特点就是查找困难，但是插入删除容易。既然两者各有优缺点，那么我们就将两者的有点结合起来，让它查找容易，插入删除也会快起来。哈希表就是讲两者结合起来的产物。
3. 哈希如何查找？
     1. 使用哈希函数将被查找的键转化为数组的索引。在理想的状态下，不同的键会被转化成不同的索引值。但是那是理想状态，我们实践当中是不可能一直是理想状态的。当不同的键生成了相同的索引的时候，也就是我们所说的冲突，我们这个时候就要处理冲突。
     2. 处理冲突的方法很多，后面我们介绍拉链法和线性探索法。
    * 哈希表是一个时间和空间上平衡的例子。如果没有空间的限制，我们可以直接用键来作为数组的索引，这样可以将查找时间做到最快（O(1)）。如果没有时间的限制，我们可以使用无序链表进行顺序查找，这样只需要很少的内存。
4. 什么是哈希函数？
    * 哈希函数其实就是我们常说的哈希算法，主要应用在以下这几个方面：文件校验、数字签名、鉴权协议。常用的哈希算法有以下这些。

    1. MD5：MD5即Message-Digest Algorithm 5(信息-摘要算法5)，用于确保信息传输完整一致。MD5是输入不定长度信息，输出固定长度128bits的算法。
    2. SHA-1：常用于HTTPS传输和软件签名。
    3. SHA-2:SHA-224/SHA-256/SHA-384/SHA-512并成为SHA-2
    4. SHA-3:之前名为Keccak算法，是一个加密杂凑算法。
5. 如何避免哈希冲突？
    1. 拉链法:基本思想就是选择足够大的M，使得所有的链表都尽可能的短小，以保证查找的效率。对采用拉链法的哈希表实现的查找分为两步，首先是根据散列值找到对应的链表，然后沿着链表的顺序找到相应的键。
    2. 线性探索法是开放寻址法解决哈希冲突的一种方法，基本原理为，使用大小为M的数组来保存N个键值对，其中M>N，我们需要使用数组中的空位来解决碰撞冲突。开放寻址法中最简单的是线性探测法：当碰撞发生时即一个键的散列值被另外一个键占用时，直接检查散列表中下一个位置，即将索引值加1，这样的线性探测有三种结果：
        1. 命中，该位置的键个被查找的键相同；
        2. 未命中，键为空；
        3. 继续查找，该位置的键和被查找的键不同。

    * 那个这两种方法的性能上面有什么区别？对于拉链法，查找的效率在于链表的长度，一般我们应该保证长度的M/8~M/2之间，如果链表的长度大于M/2，我们可以扩充数组长度。如果长度在0~M/8时，我们可以缩短数组的长度。对于线性探索法，动态调整数组的大小需要对所有的值重新进行散列并插入新的表中。
    * 不管是拉链法还是散列法，这种动态调整链表或者数组的大小以提高查询效率的同时，还应该考虑动态改变链表或者数组大小的成本。散列表长度加倍的插入需要进行大量的探索，这种均摊成本很多时候需要考虑。


