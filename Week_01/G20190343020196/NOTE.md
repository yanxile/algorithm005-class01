

学习笔记

## 数组

1. 暴力求解

2. hash表 来记录 a, b, a+b =-c， 删除重复项

3. 双指针左右下标夹逼，收窄

### 15题三数之和

+ 视频上展示那个解法不错，很合适平常修修补补的思维方式，主要大方向用升维和 空间换时间的方式， 时间允许，多想几遍，调试几遍就可以出来，锻炼一下周全考虑边界的思维。
+ 其实也很多类似这样的题，假如后面题目还挺多的话，觉得不求甚解即可。不过还是得坚持练5毒神掌。



---



## linkedList

+ 套路固定
  + 记好 next, prev，的增删改查
+ 暴力法：遍历，hash或set 记录
+ 快慢指针，步长不同

### 链表递归

+ 看链表递归时，入迷了，花了几天时间不断练习，调试， 反复做多几道题，渐入佳境，有些题可以用递归的方式做出来了
+ 这个分享写的不错，http://lylblog.cn/blog/4

![image-20191213102658394](/Users/marslee/Library/Application Support/typora-user-images/image-20191213102658394.png)

1. 整个递归的终止条件。

2. 一级递归需要做什么？

3. 应该返回给上一级的返回值是什么？

    

[Leetcode 24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)



直接上三部曲模版：

1. **找终止条件。** 什么情况下递归终止？没得交换的时候，递归就终止了呗。因此当链表只剩一个节点或者没有节点的时候，自然递归就终止了。
2. **找返回值。** 我们希望向上一级递归返回什么信息？由于我们的目的是两两交换链表中相邻的节点，因此自然希望交换给上一级递归的是已经完成交换处理，即已经处理好的链表。
3. **本级递归应该做什么。** 结合第二步，看下图！由于只考虑本级递归，所以这个链表在我们眼里其实也就三个节点：head、head.next、已处理完的链表部分。而本级递归的任务也就是交换这3个节点中的前两个节点，就很easy了。



![image-20191212235621389](/Users/marslee/Library/Application Support/typora-user-images/image-20191212235621389.png)



## Deque

+ 实战不需要用stack 和 queue,所以熟练用Deque
+ priorityQueue
+ 记住循环队列的队空和队满条件，
+ 当队满时，(tail+1)%n=head。你有没有发现，当队列满时，图中的 tail 指向的位置实际上是没有存储数据的。所以，循环队列**会浪费一个数组的存储空间。**

---

## 尚未完成任务

+ 还在看jdk 数据结构源码，写得很好，慢慢看
+ 641: 看了一下，有点思路，可以仿jdk， 还没消化，下周还得研究一下再补
+ 42：看了一下，有点思路，看了一个用stack，类似于(20.有效括号符号）找到边界的思路很不错。 应该可以做出来，还需要调试几次。

