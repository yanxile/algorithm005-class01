学习笔记

## 第三课

### 数组：

通过内存管理器访问，访问任意位置的时间复杂度为O(1)

| 操作    | 时间复杂度 |
| ------- | ---------- |
| prepend | O(1)       |
| append  | O(1)       |
| lookup  | O(1)       |
| insert  | O(n)       |
| delete  | O(n)       |

### 链表

Node，包含所存储的元素和指向下一元素的指针

​	如果同时有指向前一个元素和指向下一个元素的指针，则叫双向链表（java LinkedList）

​	如果尾节点的指针指向头节点，则是循环链表

| 操作    | 时间复杂度 |
| ------- | ---------- |
| prepend | O(1)       |
| append  | O(1)       |
| lookup  | O(n)       |
| insert  | O(1)       |
| delete  | O(1)       |



### 跳表

在链表的基础上，为了优化链表查询时O(n)的时间复杂度，所以有了跳表。

原理为：将一维的链表进行升维，新增索引（可设置多级索引）



![image-20191210225811601](images\image-20191210225811601.png)

时间复杂度：O(logn)

空间复杂度：O(n)


## 第四课

### 栈 stack

FILO(first in last out)，无序结构

时间复杂度：添加和删除都是 O(1)，查询为O(n)

栈为类，可直接使用，方法：

![image-20191214234507034](images\image-20191214234507034.png)

### 队列 queue

FIFO(first in first out)，时间复杂度与栈相同

接口，实现类有：

![image-20191214234640963](images\image-20191214234640963.png)

方法有：

![image-20191214234710341](images\image-20191214234710341.png)

### 双端队列 deque

两端都可以进行插入和删除操作的队列

![image-20191214234054661](images\image-20191214234054661.png)

时间复杂度：插入和删除都是O(1)

接口，实现类有：

![image-20191214234830379](images\image-20191214234830379.png)

方法有：

![image-20191214234810270](images\image-20191214234810270.png)

### 优先队列 priority queue

时间复杂度：插入操作O(1)   取出操作O(logN)

底层具体实现的数据结构较为多样和复杂：heap,bst,treap

方法：

![image-20191214235806999](images\image-20191214235806999.png)

