
数组
* 基础原理
    * “线性表”， 用一组’连续的’内存空间，存储“相同类型”的数据。
    * 所谓线性就是像一条线一样， 有前后关系， 比如链表、栈、队列。 相对的非线性的数据结构有 树、图、堆等等。
    * 连续的内存空间更加利于CPU 缓存（cpu 每次是读取一个），但是为了保证这个特性，在插入和删除数据的时候需要做数据搬移，导致时间复杂度为O(n)，
数据元素的访问是先通过寻址公式找到元素的内存地址， 从而找到元素， 时间复杂度为O(1). 但是数组的查找时间复杂度并不是O(1),
即使是有序数组的查找时间复杂度也是logn
    * 数组插入的优化： 如果不要求有序，我们可以把要插入数据位置的元素挪到元素最后一位，再将元素插入， (快排)
    * 数组删除的优化： 可以先标记为已删除，当数组没有足够空间的时候再集中出发删除， 可以大大减少数据搬移。 
        * 批量的思想，这种思想或者设计思路在工程应用中比较常见。 比如： kafka的批量发送消息、HashMap批量搬移数据、垃圾回收机制
* 编程语言中的实现， 如Java ArrayList， Redis 的字符串是可变长数组，C语言中的字符串是以\0结尾的字符数组， python 的list
* 双指正技巧、快慢指针技巧
链表
* 基础原理
* 应用
    * 双向链表
    * 循环链表
    * 循环双向链表
* 链表编程技巧
    * 使用哨兵-如p = ListNode(-1) ， 极大简化编程难度- 如链表的两两交换
    * dummy node

数组与链表的对比
* 数组随机访问时间复杂度O(1)，插入删除时间复杂度O(n)
* 数组内存是连续的对CPU缓存友好
* 链表不支持随机访问，查找元素时间复杂度O(n), 头尾插入删除时间复杂度O(1)， 不需要搬移数据
* 链表更加适合用来做插入、删除比较频繁的操作

栈 Stack
* 后进先出
* 应用
    * 函数调用
    * 表达式求值
    * 浏览器前进后退
    * 树的遍历？？
    * 数进制转换
* StackOverFlow
* 数组实现-顺序栈 内存连续
* 链表实现-链式栈
队列  Queue
* 先进先出
* 应用
    * 需要由资源竞争的情况
    * 削峰填谷
    * 秒杀排队
    * 异步消息队列
* 工程应用
    * 循环队列
    * 并发队列
    * 阻塞队列
        * 生产者消费者模型
    * 循环并发队列
        * 高性能Disruptor
        * Linux 环形缓存
        * Java实现：ArrayBlockingQueue
* 优先队列
    * 实际上就是一个堆
* 双端队列 Deque
    * 头尾都可O(1) 进出

* * *

* [Stack In Python](https://www.geeksforgeeks.org/stack-in-python/)
* https://www.geeksforgeeks.org/implementation-deque-using-doubly-linked-list/
