【0290_Week 01】学习总结
## 一、重点需要再次回忆：
1. 必经之路——**五毒神掌**；
2. 怎么化繁为简——**升维，空间换时间**
3. 没有思路的时候怎么办：
第一步：能不能**暴力**解？
如果不能，进行第二步：**数学归纳**法，先把前2种情况一一列举，然后 --> 找最近的重复子问题（`if/else`、`for`、`while`、`recursion`）

## 二、栈的巧妙应用题目
直方图中能拼成的最大长方形面积。

## 三、栈和队列间的相互实现
用栈实现队列或者用队列实现栈的解题思路是一样的：即用 `2`个栈实现 `1`个队列或者用 `2`个队列实现 `1`个栈，第 `2`个数据结构把顺序颠倒回来即可。

## 四、通解之滑动窗口
所有滑动窗口的题目都可以使用队列去解（` O(n) `）。

## 五、第四课要求作业
1. **改写代码**
```java
Deque<String> deque = new LinkedList<>();
deque.addFirst("a");

deque.addFirst("b");
deque.addFirst("c");
System.out.println(deque);

String str = deque.peekFirst();
System.out.println(str);
System.out.println(deque);

while(deque.size() > 0) {
    System.out.println(deque.pollFirst());
}

System.out.println(deque);
```
2. **分析源码**
（1）**Queue**
`Queue`的源码基本上根据方法名可以做到“顾名思义”，在实现上首先看其静态内部类 `Node`的实现，从这个子类的实现就可以看出这个 `Queue`是一个双向队列还是单向队列。当熟悉了这个 `Node`类后再看 `Queue`实现类具体API的实现时就能“顺藤摸瓜”了。
（2）**PriorityQueue**
这里以Java的 `PriorityBlockingQueue`为例，该类内部有一个数组 `queue`，用来存放队列元素， `size`用来存放元素个数。`allocationSpinLock`是个自旋锁，其使用 `CAS`操作来保证同时只有一个线程可以扩容队列，状态为 `0`或 `1`（ `0`表示当前没有扩容；`1`表示当前正在扩容，扩容方式是熟悉的`System.arrayCopy`）。
由于这是一个优先级队列，所以有一个比较器 `comparator`用来比较元素大小。 `1ock`独占锁对象（`ReentrantLock`）用来控制同时只能有一个线程可以进行入队、出队操作。 `notEmpty`条件变量用来实现 `take`方法阻塞模式。这里没有 `notFull`条件变量是因为这里的 `put`操作是非阻塞的，为啥要设计为非阻塞的，是因为这是无界队列。
了解了以上基础知识后，再看该类具体API实现就会轻松很多了，具体API分析参考代码和上面的解释即可理解。

## 六、第一周做题感想
1. **生活与学习**
第一周下来主要感觉是适应教学方式，熟悉了对于这门算法课的时间安排、学习内容自排。个人觉得这个其实非常重要，因为如果在一开始能够将教学节奏和自己的生活工作节奏很好地结合起来的话才能够在接下来的课程里真正把这门课当做自己生活的一部分，而不是我得找个这个时间、那个时间地匆忙安排。
2. **解题的一些小感悟**
（1）在第一次解"66.Plus One"时虽然思路和后来看得题解推荐解法一致，但是写出的有效代码却比其多了好几行，经过借鉴后进行了精简，代码技巧得到了提高，唯一遗憾的是运行速度和内存占用相差无几。
（2）在看一些官方题解时，比如"88.Merge Sorted Array"，推荐的java实现中有涉及到“System.arrayCopy”这种操作，虽然并没有怎么影响到时间成绩，但是作为java程序员还是应该尽量避免这种内存拷贝操作，比如这道题我认为即便是使用3个指针、代码多几行也比这种内存拷贝的代码要更舒服。